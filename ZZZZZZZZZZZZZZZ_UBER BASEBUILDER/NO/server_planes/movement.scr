// automatically generated by MOH Piler 3
// shell idea stolen from jv:P

main local.t local.arg1 local.arg2:

	//check plane is not dead
	if(self.plane == NULL || self.plane == NIL)
	{
		end
	}
	
	//self becomes plane
	self.plane thread local.t local.arg1 local.arg2

end

angles local.angle:

	
	switch(local.angle)
	{
	case 1:	//pitch down
		local.change = (self.leftvector * 0.05)
	break
	case 2:	//pitch up
		local.change = (self.leftvector * -0.05)// ~25 deg/s
	break
	case 3:	//yaw left
		local.change = (self.upvector * 0.0101)// ~25 deg/
		local.change += (self.forwardvector * -0.10) // ~25 deg/s
	break
	case 4:	//yaw right
		local.change = (self.upvector * -0.0101)// ~25 deg/
		local.change += (self.forwardvector * 0.10) // ~25 deg/s
	break
	}

	exec server_planes/angles.scr::axisrotate local.change
end


speed local.movement:

	switch(local.movement)
	{
	case 2:
		self.speed -= self.deceleration

		if(self.speed < self.minspeed)
		{
			self.speed =  self.minspeed
		}
		
	break
	case 1:

		self.speed += self.acceleration
		if(self.speed > self.maxspeed)
		{
			self.speed =  self.maxspeed
		}
	
	break
	case "LEFT_WALK":
	break
	case "RIGHT_WALK":
	break

	}
end

jump:

	self.pilot.flying = 0
	if(game.game == "AA")
	{
		self.pilot exec server_planes/parachute.scr
	}
	else
	{
		self.pilot exec server_planes/parachute_sh.scr
	}
end

freelook:
	
	if(self.freelook == 1)
	{
		self.freelook = 0
	}
	else
	{
		self.freelook = 1
	}
end 

// Sets new angles for the plane. 
// threaded to like so local.plane thread change_angles ( 0 0 1 )
// WIll add 1 to the z
// used for roll
change_angles local.angles:
//
	self.angles += local.angles
	
end